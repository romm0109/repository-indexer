import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import OpenAI from 'openai';

@Injectable()
export class QueryRefinementService {
  private readonly logger = new Logger(QueryRefinementService.name);
  private openai: OpenAI | null = null;
  private modelName: string;

  constructor(private configService: ConfigService) {
    const refineUrl = this.configService.get<string>('app.refine.url');
    const refineApiKey = this.configService.get<string>('app.refine.apiKey');
    this.modelName =
      this.configService.get<string>('app.refine.modelName') || 'gpt-4o-mini';

    if (refineApiKey) {
      this.openai = new OpenAI({
        apiKey: refineApiKey,
        baseURL: refineUrl,
      });
    } else {
      this.logger.warn(
        'Refinement API key not found. Query refinement will be disabled.',
      );
    }
  }

  async refineQuery(query: string, prompt: string): Promise<string[]> {
    if (!this.openai) {
      this.logger.warn(
        'Query refinement requested but service is not configured. Returning original query.',
      );
      return [query];
    }

    try {
      const systemPrompt = `You are an expert software engineer. The user is searching a codebase. Use the provided context to generate 3-5 specific and effective search queries based on the user's original query. Output the queries as a JSON array of strings.`;
      const userContent = `Context: ${prompt}\nQuery: ${query}`;

      const completion = await this.openai.chat.completions.create({
        model: this.modelName,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userContent },
        ],
        response_format: { type: 'json_object' },
      });

      const content = completion.choices[0].message.content;
      if (!content) {
        throw new Error('Empty response from LLM');
      }

      const parsed = JSON.parse(content);
      // Expecting { "queries": [...] } or just [...] depending on how the model behaves with json_object.
      // Let's be robust.
      let queries: string[] = [];
      if (Array.isArray(parsed)) {
        queries = parsed;
      } else if (parsed.queries && Array.isArray(parsed.queries)) {
        queries = parsed.queries;
      } else {
        // Fallback: try to find an array in the object values
        const values = Object.values(parsed);
        const arrayValue = values.find((v) => Array.isArray(v));
        if (arrayValue) {
          queries = arrayValue as string[];
        }
      }

      if (queries.length === 0) {
        this.logger.warn('No queries generated by LLM. Using original query.');
        return [query];
      }

      return queries;
    } catch (error) {
      this.logger.error(
        `Failed to refine query: ${error instanceof Error ? error.message : String(error)}`,
      );
      return [query];
    }
  }
}
